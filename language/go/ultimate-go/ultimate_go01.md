### 포인터
- 모든 함수는 스택 프레임을 가짐
- 함수의 메모리 수행을 의미
- 모든 스택 프레임의 크기는 컴파일 때 알 수 있음
- 컴파일 크기를 알 수 없는 값이 스택에 자리를 잡을 수는 없음
- 그건 힙에 저장
- 제로 값(?) 덗분에 모든 스택 프레임을 초기화 할 수 있음
- 스택은 알아서 정리되며, 방향은 아래쪽
- 함수를 만들때마다 제로값으로 스택 프레임을 초기화하며 정리 
메모리를 떠날떄는 다시 필요하게 될지 모르기 때문에 위쪽으로 떠남
- 스택프레임은 재사용 가능한 메모리


### zero value 
- https://www.hahwul.com/2021/08/09/do-you-know-about-golang-nil/
- zero value란 초기값을 가지지 않고 변수를 만들수있을때 해당 변수가 가질 값을 의미

### escape analysis
- 무엇을 스택에 둘지 힙에 둘지
- 무언가 콜스택 위쪽으로 무언가를 공유할떄는
힙에 지정
- 스택 공간이 부족해지면 ..?
스택은 커질 수 있기 때문에 하나의 고루틴이 다른 고루틴의 스택 메모리에 대한 포인터를 가질 수 없음ㄴ
컴파일러가 모든 포인터를  추적하는 것은 지나친 과부하

### 가비지 컬렉션
- 힙에 저장하는 것은 가비지 컬렉션이 개입
- pacing algorithm
  - 최소한의 가비지 컬렉션 작업시간 t가 소요되도록 어떠한 주기와 페이스로 가비지 컬렉션을 실행할 지 결정해야 됨
- gc가 작동할때는 성능이 떨어질 수 밖에 없음

### data structure
#### array
- cpu cache
  - 코어들은 메인 메모리로 바로 접근하지 않고 로컬 캐시로 접근
  - 속도는 l1 > l2 > l3
  - 캐시 미스가 발생하지 않거나 최소화하는 캐싱 시스템 필요
  - 프로세서는 프리패처를 가지고 있음
  - 프리패처는 어떤 데이터가 필요할 지 예상



### slice 
- idea of appending: make slice a dynamic data structure
- `var data[] string` 
-  `data := string{}`
Cf) length vs capacity
- cap : 현재 슬라이스에 주소값의 변경없이 포함시킬 수 있는 요소의 개수
- 슬라이스의 cap을 초과할 경우 용량은 두배씩 증가 -> 주소값이 변경
- 슬라이스의 용량을 초과하는것을 리 슬라이싱이라 
