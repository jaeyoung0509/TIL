## 헥사고날의 장점 
- 아키텍처적으로 표현력 있는 패키지 구조 
- 아키텍처 - 코드 갭  , 모델-코드 갭을 효과적으로 다룰 수  있는 강력한 요소 
- ddd 개념에 직접적으로 대응시킬 수 있음
- - bounded context 와 통신할 전용 진입점과 출구를 포함하는 바운디드 컨텍스트에 해당
- 핵심은 `엔티티` `유스케이스` `인커밍 - 아웃고잉 포트`  `인커밍 아웃고잉 어댑터`
- 구조의 각 요들은 패키지 하나씩 직접 매핑 
- 컨트롤러가 서비스에 의해 구현된 인커밍 포트를 호출, 서비스는 어댑터에 의해 구현된 아웃고잉 포트를 호출

### 의존성 주입의 역할 
- 클린 아키텍처의 본질적인 요건은 인커밍 - 아웃고잉 어댑터에 의존성을 갖지 않는 것 

### 유스케이스 
- 애플리케이션, 웹 ,영속성 계층이  느슨하게 결합게 되어 있기 때문에 자유롭게 모델링 가능 
- ddd를 할 수 있고, rich, anemic 도메인 모델을 구현할 수 도 있음 
- 육각 아키텍처는 도메인 중심의 아키텍처에 적합하기 때문에 도메인 엔티티를 만드는것으로 시작한 후 도메인 엔티티를 중심으로 유스케이스 구현 
#### 유스케이스 둘러보기 
- 입력
- 비지니스 규칙 
- 모델 상태를 조직
- 출력을 반환
- 유스케이스는 인커밍 어댑터로부터 입력을 받음 (`유효성 검증`) 
- 유스케이스 코드는 도메인 로직에만 신경 써야 됨 ,  유효성 검증으로 오염이 되면 안됨
- 그러나 `유스케이스는 비지니스 규칙`을 검증할 책임이 있음
- 그리고 도메인 엔티티와 이 책임을 공유
- 그럼 `입력 유효성 검증` 과 `비지니스 규칙 검증`의 차이는 뭘까?
- 비지니스 규칙을 충족하면, 유스케이스는 입력을 기반으로 어떤방법이든 모델의 상태를 변경
- 이를 통해 넓은 서비스 문제 해결 가능
- `입력 유효성 검증` 은 어플리케이션 계층에서,
- - 이렇게하지 않을 경우, 어플리케이션 코어 바깥으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수가 있음 
- - 입력 모델에 있는 유효성 검증 코드를 통해 유스케이스 구현체 주위에 사실상 오류 방지계층을 만듬
- - 하위 계층을 호출하는 계층형 아키텍처에서의 계층이 아니라 잘못된 입력을 호출자에게 돌려주는 유스케이스 `보호막`
#### 유스케이스 마다 다른 입력모델
- 각기 다른 유스케이스에 동일한 입력모델을 사용하고 싶음
(계좌 등록 , 계좌 정보 업데이트) 둘 다 같은 계좌 모델이 필요
- - 불변 커맨드 객체의 필드에 대해서 null을 유효한 상태로 받아들이는 것은 그자체로 코드 냄새
- - 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와 결합도 제거해서 부수효과가 발생하지 않음 

#### 비지니스 규칙 검증하기
- 비지니스 규칙 검증은 유스케이스 로직의 일부
- 언제 입력 유효성을 검증? 언제 비지니스 규칙 검증?